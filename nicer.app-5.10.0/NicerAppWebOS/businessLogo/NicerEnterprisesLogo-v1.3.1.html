<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NicerEnterprises Company Logo v5.3.1</title>
    <!--
    2025-07-23 03:00am to 2025-07-24 06:00am :
        I, Rene AJM Veerman would like to thank @elonmusk, @xAI and @grok for helping me draft
        and debug this 3D logo from "scratch" in under 30 hours total! :-)
    -->
    <style>
        body { margin: 0; background-color: transparent; overflow:hidden; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Initialize scene, camera, and renderer with alpha
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Set clear color to transparent
        document.body.appendChild(renderer.domElement);

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Create a group for auto-rotation
        const group = new THREE.Group();
        scene.add(group);

        // Define sphere parameters
        const innerRadius = 1;
        const middleRadius = 1.5;
        const outerRadius = 2;
        const r = outerRadius * 1.52; // Position radius for octagons and arrows

        // Create three overlapping spheres
        const innerSphereGeo = new THREE.SphereGeometry(innerRadius, 32, 32);
        const middleSphereGeo = new THREE.SphereGeometry(middleRadius, 32, 32);
        const outerSphereGeo = new THREE.SphereGeometry(outerRadius, 32, 32);

        const innerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
        const middleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        const textureLoader = new THREE.TextureLoader();
        const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
        const outerMaterial = new THREE.MeshBasicMaterial({ map: earthTexture, transparent: true, opacity: 0.5 });

        const innerSphere = new THREE.Mesh(innerSphereGeo, innerMaterial);
        const middleSphere = new THREE.Mesh(middleSphereGeo, middleMaterial);
        const outerSphere = new THREE.Mesh(outerSphereGeo, outerMaterial);

        group.add(innerSphere, middleSphere, outerSphere);

        /*
        // Define tetrahedron geometry (radius 0.5 for a moderate size)
        const tetrahedronGeo = new THREE.TetrahedronGeometry(0.5);

        // Material (reusing the octagon material properties)
        const tetrahedronMaterial = new THREE.MeshBasicMaterial({
        color: 0x888888,
        transparent: true,
        opacity: 0.5
        });
        */

        // Define sphere geometry with 50 faces (widthSegments=5, heightSegments=5)
        const sphereGeo = new THREE.SphereGeometry(0.25, 5, 5);

        // Define material (assuming same properties as the original tetrahedrons)
        const sphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xFF0000,
        transparent: true,
        opacity: 0.5
        });

        // Define positions and rotations (same as the original tetrahedrons)
        //const r = 2.4; // Example distance, adjust based on your outerRadius * 1.2
        const sphereData = [
        { position: [0, 0, r], rotation: [0, 0, 0] },         // North
        { position: [0, 0, -r], rotation: [Math.PI, 0, 0] },  // South
        { position: [r, 0, 0], rotation: [0, Math.PI / 2, 0] }, // East
        { position: [-r, 0, 0], rotation: [0, -Math.PI / 2, 0] }, // West
        { position: [0, r, 0], rotation: [-Math.PI / 2, 0, 0] }, // South Zenith
        { position: [0, -r, 0], rotation: [Math.PI / 2, 0, 0] }  // North Zenith
        ];

        // Add spheres to the group (assuming 'group' is your Three.js group or scene)
        sphereData.forEach(data => {
        const mesh = new THREE.Mesh(sphereGeo, sphereMaterial);
        mesh.position.set(...data.position);
        mesh.rotation.set(...data.rotation); // Optional, as spheres are symmetric
        group.add(mesh);
        });

        /* PACMAN :
        // Create octagon geometry (2D shape extruded to 3D)
        const octagonShape = new THREE.Shape();
        const numSides = 12;
        const angleStep = 2 * Math.PI / numSides;
        for (let i = 0; i < numSides; i++) {
            const angle = i * angleStep;
            octagonShape.lineTo(Math.cos(angle), Math.sin(angle));
        }
        octagonShape.closePath();
        const extrudeSettings = { depth: 0.1, bevelEnabled: false };
        const octagonGeo = new THREE.ExtrudeGeometry(octagonShape, extrudeSettings);
        const octagonMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.5 });

        // Define octagon positions and rotations (90-degree angles)
        const octagonData = [
            { position: [0, 0, r], rotation: [0, 0, 0] },         // N
            { position: [0, 0, -r], rotation: [Math.PI, 0, 0] },  // S
            { position: [r, 0, 0], rotation: [0, Math.PI / 2, 0] }, // E
            { position: [-r, 0, 0], rotation: [0, -Math.PI / 2, 0] }, // W
            { position: [0, r, 0], rotation: [-Math.PI / 2, 0, 0] }, // SZ (zenith)
            { position: [0, -r, 0], rotation: [Math.PI / 2, 0, 0] }  // NZ (nadir)
        ];

        octagonData.forEach(data => {
            const mesh = new THREE.Mesh(octagonGeo, octagonMaterial);
            mesh.position.set(...data.position);
            mesh.rotation.set(...data.rotation);
            group.add(mesh);
        });
        */

        // Create arrow geometry (cylinder body + cone head)
        const bodyLength = 0.5;
        const bodyRadius = 0.05;
        const headLength = 0.2;
        const headRadius = 0.1;
        const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xffa100 }); // Yellow arrows

        const bodyGeo = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyLength, 16);
        const headGeo = new THREE.ConeGeometry(headRadius, headLength, 16);

        const arrowPrototype = new THREE.Group();
        const bodyMesh = new THREE.Mesh(bodyGeo, arrowMaterial);
        bodyMesh.rotation.x = -Math.PI / 2; // Align with -z
        bodyMesh.position.z = -bodyLength / 2;
        const headMesh = new THREE.Mesh(headGeo, arrowMaterial);
        headMesh.rotation.x = -Math.PI / 2; // Align with -z
        headMesh.position.z = -bodyLength;
        arrowPrototype.add(bodyMesh, headMesh);

        // Define arrow positions (45-degree angles)
        const arrowData = [
            // Equator arrows (phi = 90 degrees)
            { theta: Math.PI / 4, phi: Math.PI / 2 },      // NE
            { theta: 3 * Math.PI / 4, phi: Math.PI / 2 },  // NW
            { theta: 5 * Math.PI / 4, phi: Math.PI / 2 },  // SW
            { theta: 7 * Math.PI / 4, phi: Math.PI / 2 },  // SE
            // Upper hemisphere arrows (phi = 45 degrees from top)
            { theta: Math.PI / 4, phi: Math.PI / 4 },      // NEZ (top)
            { theta: 3 * Math.PI / 4, phi: Math.PI / 4 },  // NWZ (top)
            { theta: 5 * Math.PI / 4, phi: Math.PI / 4 },  // SWZ (top)
            { theta: 7 * Math.PI / 4, phi: Math.PI / 4 },  // SEZ (top)
            // Lower hemisphere arrows (phi = 135 degrees from top)
            { theta: Math.PI / 4, phi: 3 * Math.PI / 4 },  // NE bottom
            { theta: 3 * Math.PI / 4, phi: 3 * Math.PI / 4 }, // NW bottom
            { theta: 5 * Math.PI / 4, phi: 3 * Math.PI / 4 }, // SW bottom
            { theta: 7 * Math.PI / 4, phi: 3 * Math.PI / 4 }  // SE bottom
        ];
        arrowData.forEach(data => {
            const { theta, phi } = data;
            const position = new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            );
            const arrow = arrowPrototype.clone();
            arrow.position.copy(position);
            arrow.lookAt(0, 0, 0); // +z points to center, so -z (arrow direction) points outward
            group.add(arrow);
        });

        // Enable OrbitControls for mouse movement
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Animation loop for auto-rotation
        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y -= 0.01; // Rotate around y-axis
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
