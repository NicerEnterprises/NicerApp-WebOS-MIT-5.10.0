<!DOCTYPE html>
<html>
<head>
    <title>Three.js Scene</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Initialize scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Create a group for auto-rotation
        const group = new THREE.Group();
        scene.add(group);

        // Define sphere parameters
        const innerRadius = 1;
        const middleRadius = 1.5;
        const outerRadius = 2;
        const r = outerRadius * 1.2; // Position radius for octagons and arrows

        // Create three overlapping spheres
        const innerSphereGeo = new THREE.SphereGeometry(innerRadius, 32, 32);
        const middleSphereGeo = new THREE.SphereGeometry(middleRadius, 32, 32);
        const outerSphereGeo = new THREE.SphereGeometry(outerRadius, 32, 32);

        const innerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
        const middleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        const textureLoader = new THREE.TextureLoader();
        const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'); // Public Earth texture
        const outerMaterial = new THREE.MeshBasicMaterial({ map: earthTexture, transparent: true, opacity: 0.5 });

        const innerSphere = new THREE.Mesh(innerSphereGeo, innerMaterial);
        const middleSphere = new THREE.Mesh(middleSphereGeo, middleMaterial);
        const outerSphere = new THREE.Mesh(outerSphereGeo, outerMaterial);

        group.add(innerSphere, middleSphere, outerSphere);

        // Create octagon geometry (2D shape extruded to 3D)
        const octagonShape = new THREE.Shape();
        const numSides = 8;
        const angleStep = 2 * Math.PI / numSides;
        for (let i = 0; i < numSides; i++) {
            const angle = i * angleStep;
            octagonShape.lineTo(Math.cos(angle), Math.sin(angle));
        }
        octagonShape.closePath();
        const extrudeSettings = { depth: 0.1, bevelEnabled: false };
        const octagonGeo = new THREE.ExtrudeGeometry(octagonShape, extrudeSettings);
        const octagonMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.5 });

        // Define octagon positions and rotations (90-degree angles)
        const octagonData = [
            { position: [0, 0, r], rotation: [0, 0, 0] },         // N
            { position: [0, 0, -r], rotation: [Math.PI, 0, 0] },  // S
            { position: [r, 0, 0], rotation: [0, Math.PI / 2, 0] }, // E
            { position: [-r, 0, 0], rotation: [0, -Math.PI / 2, 0] }, // W
            { position: [0, r, 0], rotation: [-Math.PI / 2, 0, 0] }, // SZ (zenith)
            { position: [0, -r, 0], rotation: [Math.PI / 2, 0, 0] }  // NZ (nadir)
        ];

        octagonData.forEach(data => {
            const mesh = new THREE.Mesh(octagonGeo, octagonMaterial);
            mesh.position.set(...data.position);
            mesh.rotation.set(...data.rotation);
            group.add(mesh);
        });

        // Create arrow geometry (cylinder body + cone head)
        const bodyLength = 0.5;
        const bodyRadius = 0.05;
        const headLength = 0.2;
        const headRadius = 0.1;
        const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow arrows

        const bodyGeo = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyLength, 16);
        const headGeo = new THREE.ConeGeometry(headRadius, headLength, 16);

        const arrowPrototype = new THREE.Group();
        const bodyMesh = new THREE.Mesh(bodyGeo, arrowMaterial);
        bodyMesh.rotation.x = -Math.PI / 2; // Align with -z
        bodyMesh.position.z = -bodyLength / 2;
        const headMesh = new THREE.Mesh(headGeo, arrowMaterial);
        headMesh.rotation.x = -Math.PI / 2; // Align with -z
        headMesh.position.z = -bodyLength;
        arrowPrototype.add(bodyMesh, headMesh);

        // Define arrow positions (45-degree angles)
        const arrowData = [
            { theta: Math.PI / 4, phi: Math.PI / 2 },      // NE
            { theta: 3 * Math.PI / 4, phi: Math.PI / 2 },  // NW
            { theta: 5 * Math.PI / 4, phi: Math.PI / 2 },  // SW
            { theta: 7 * Math.PI / 4, phi: Math.PI / 2 },  // SE
            { theta: Math.PI / 4, phi: Math.PI / 4 },      // NEZ
            { theta: 3 * Math.PI / 4, phi: Math.PI / 4 },  // NWZ
            { theta: 5 * Math.PI / 4, phi: Math.PI / 4 },  // SWZ
            { theta: 7 * Math.PI / 4, phi: Math.PI / 4 }   // SEZ
        ];

        arrowData.forEach(data => {
            const { theta, phi } = data;
            const position = new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            );
            const arrow = arrowPrototype.clone();
            arrow.position.copy(position);
            arrow.lookAt(0, 0, 0); // +z points to center, so -z (arrow direction) points outward
            group.add(arrow);
        });

        // Enable OrbitControls for mouse movement
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Animation loop for auto-rotation
        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y += 0.01; // Rotate around y-axis
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
